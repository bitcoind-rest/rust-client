/* 
 * Bitcoind
 *
 * The REST API can be enabled with the `-rest` option. The interface runs on the same port as the JSON-RPC interface, by default port `8332` for **mainnet**, port `18332` for **testnet**, and port `18443` for **regtest**.
 *
 * OpenAPI spec version: 0.16
 * Contact: johan@lepetitbloc.net
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Block {
  /// The block hash
  #[serde(rename = "hash")]
  hash: Option<String>,
  /// The number of confirmations
  #[serde(rename = "confirmations")]
  confirmations: Option<i64>,
  /// The block stripped size
  #[serde(rename = "strippedsize")]
  strippedsize: Option<i64>,
  /// The block size
  #[serde(rename = "size")]
  size: Option<i64>,
  /// The block weight
  #[serde(rename = "weight")]
  weight: Option<i64>,
  /// The block height (or index)
  #[serde(rename = "height")]
  height: Option<i64>,
  /// The block version
  #[serde(rename = "version")]
  version: Option<i64>,
  /// The block version (in hex)
  #[serde(rename = "versionHex")]
  version_hex: Option<String>,
  /// The block merkle root
  #[serde(rename = "merkleroot")]
  merkleroot: Option<String>,
  /// The list of transactions in the block
  #[serde(rename = "tx")]
  tx: Option<Vec<::models::Transaction>>,
  /// The block time
  #[serde(rename = "time")]
  time: Option<i32>,
  /// The block median time
  #[serde(rename = "mediantime")]
  mediantime: Option<i32>,
  /// The block nonce
  #[serde(rename = "nonce")]
  nonce: Option<i32>,
  #[serde(rename = "bits")]
  bits: Option<String>,
  #[serde(rename = "difficulty")]
  difficulty: Option<f32>,
  #[serde(rename = "chainwork")]
  chainwork: Option<String>
}

impl Block {
  pub fn new() -> Block {
    Block {
      hash: None,
      confirmations: None,
      strippedsize: None,
      size: None,
      weight: None,
      height: None,
      version: None,
      version_hex: None,
      merkleroot: None,
      tx: None,
      time: None,
      mediantime: None,
      nonce: None,
      bits: None,
      difficulty: None,
      chainwork: None
    }
  }

  pub fn set_hash(&mut self, hash: String) {
    self.hash = Some(hash);
  }

  pub fn with_hash(mut self, hash: String) -> Block {
    self.hash = Some(hash);
    self
  }

  pub fn hash(&self) -> Option<&String> {
    self.hash.as_ref()
  }

  pub fn reset_hash(&mut self) {
    self.hash = None;
  }

  pub fn set_confirmations(&mut self, confirmations: i64) {
    self.confirmations = Some(confirmations);
  }

  pub fn with_confirmations(mut self, confirmations: i64) -> Block {
    self.confirmations = Some(confirmations);
    self
  }

  pub fn confirmations(&self) -> Option<&i64> {
    self.confirmations.as_ref()
  }

  pub fn reset_confirmations(&mut self) {
    self.confirmations = None;
  }

  pub fn set_strippedsize(&mut self, strippedsize: i64) {
    self.strippedsize = Some(strippedsize);
  }

  pub fn with_strippedsize(mut self, strippedsize: i64) -> Block {
    self.strippedsize = Some(strippedsize);
    self
  }

  pub fn strippedsize(&self) -> Option<&i64> {
    self.strippedsize.as_ref()
  }

  pub fn reset_strippedsize(&mut self) {
    self.strippedsize = None;
  }

  pub fn set_size(&mut self, size: i64) {
    self.size = Some(size);
  }

  pub fn with_size(mut self, size: i64) -> Block {
    self.size = Some(size);
    self
  }

  pub fn size(&self) -> Option<&i64> {
    self.size.as_ref()
  }

  pub fn reset_size(&mut self) {
    self.size = None;
  }

  pub fn set_weight(&mut self, weight: i64) {
    self.weight = Some(weight);
  }

  pub fn with_weight(mut self, weight: i64) -> Block {
    self.weight = Some(weight);
    self
  }

  pub fn weight(&self) -> Option<&i64> {
    self.weight.as_ref()
  }

  pub fn reset_weight(&mut self) {
    self.weight = None;
  }

  pub fn set_height(&mut self, height: i64) {
    self.height = Some(height);
  }

  pub fn with_height(mut self, height: i64) -> Block {
    self.height = Some(height);
    self
  }

  pub fn height(&self) -> Option<&i64> {
    self.height.as_ref()
  }

  pub fn reset_height(&mut self) {
    self.height = None;
  }

  pub fn set_version(&mut self, version: i64) {
    self.version = Some(version);
  }

  pub fn with_version(mut self, version: i64) -> Block {
    self.version = Some(version);
    self
  }

  pub fn version(&self) -> Option<&i64> {
    self.version.as_ref()
  }

  pub fn reset_version(&mut self) {
    self.version = None;
  }

  pub fn set_version_hex(&mut self, version_hex: String) {
    self.version_hex = Some(version_hex);
  }

  pub fn with_version_hex(mut self, version_hex: String) -> Block {
    self.version_hex = Some(version_hex);
    self
  }

  pub fn version_hex(&self) -> Option<&String> {
    self.version_hex.as_ref()
  }

  pub fn reset_version_hex(&mut self) {
    self.version_hex = None;
  }

  pub fn set_merkleroot(&mut self, merkleroot: String) {
    self.merkleroot = Some(merkleroot);
  }

  pub fn with_merkleroot(mut self, merkleroot: String) -> Block {
    self.merkleroot = Some(merkleroot);
    self
  }

  pub fn merkleroot(&self) -> Option<&String> {
    self.merkleroot.as_ref()
  }

  pub fn reset_merkleroot(&mut self) {
    self.merkleroot = None;
  }

  pub fn set_tx(&mut self, tx: Vec<::models::Transaction>) {
    self.tx = Some(tx);
  }

  pub fn with_tx(mut self, tx: Vec<::models::Transaction>) -> Block {
    self.tx = Some(tx);
    self
  }

  pub fn tx(&self) -> Option<&Vec<::models::Transaction>> {
    self.tx.as_ref()
  }

  pub fn reset_tx(&mut self) {
    self.tx = None;
  }

  pub fn set_time(&mut self, time: i32) {
    self.time = Some(time);
  }

  pub fn with_time(mut self, time: i32) -> Block {
    self.time = Some(time);
    self
  }

  pub fn time(&self) -> Option<&i32> {
    self.time.as_ref()
  }

  pub fn reset_time(&mut self) {
    self.time = None;
  }

  pub fn set_mediantime(&mut self, mediantime: i32) {
    self.mediantime = Some(mediantime);
  }

  pub fn with_mediantime(mut self, mediantime: i32) -> Block {
    self.mediantime = Some(mediantime);
    self
  }

  pub fn mediantime(&self) -> Option<&i32> {
    self.mediantime.as_ref()
  }

  pub fn reset_mediantime(&mut self) {
    self.mediantime = None;
  }

  pub fn set_nonce(&mut self, nonce: i32) {
    self.nonce = Some(nonce);
  }

  pub fn with_nonce(mut self, nonce: i32) -> Block {
    self.nonce = Some(nonce);
    self
  }

  pub fn nonce(&self) -> Option<&i32> {
    self.nonce.as_ref()
  }

  pub fn reset_nonce(&mut self) {
    self.nonce = None;
  }

  pub fn set_bits(&mut self, bits: String) {
    self.bits = Some(bits);
  }

  pub fn with_bits(mut self, bits: String) -> Block {
    self.bits = Some(bits);
    self
  }

  pub fn bits(&self) -> Option<&String> {
    self.bits.as_ref()
  }

  pub fn reset_bits(&mut self) {
    self.bits = None;
  }

  pub fn set_difficulty(&mut self, difficulty: f32) {
    self.difficulty = Some(difficulty);
  }

  pub fn with_difficulty(mut self, difficulty: f32) -> Block {
    self.difficulty = Some(difficulty);
    self
  }

  pub fn difficulty(&self) -> Option<&f32> {
    self.difficulty.as_ref()
  }

  pub fn reset_difficulty(&mut self) {
    self.difficulty = None;
  }

  pub fn set_chainwork(&mut self, chainwork: String) {
    self.chainwork = Some(chainwork);
  }

  pub fn with_chainwork(mut self, chainwork: String) -> Block {
    self.chainwork = Some(chainwork);
    self
  }

  pub fn chainwork(&self) -> Option<&String> {
    self.chainwork.as_ref()
  }

  pub fn reset_chainwork(&mut self) {
    self.chainwork = None;
  }

}




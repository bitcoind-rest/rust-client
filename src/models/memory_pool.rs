/* 
 * Bitcoind
 *
 * The REST API can be enabled with the `-rest` option. The interface runs on the same port as the JSON-RPC interface, by default port `8332` for **mainnet**, port `18332` for **testnet**, and port `18443` for **regtest**.
 *
 * OpenAPI spec version: 0.16
 * Contact: johan@lepetitbloc.net
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct MemoryPool {
  /// the number of transactions in the TX mempool
  #[serde(rename = "size")]
  size: Option<i64>,
  /// size of the TX mempool in bytes
  #[serde(rename = "bytes")]
  bytes: Option<i64>,
  /// total TX mempool memory usage
  #[serde(rename = "usage")]
  usage: Option<i64>,
  /// maximum memory usage for the mempool in bytes
  #[serde(rename = "maxmempool")]
  maxmempool: Option<i64>,
  /// minimum feerate (BTC per KB) for tx to be accepted
  #[serde(rename = "mempoolminfee")]
  mempoolminfee: Option<f32>,
  #[serde(rename = "minrelaytxfee")]
  minrelaytxfee: Option<f32>
}

impl MemoryPool {
  pub fn new() -> MemoryPool {
    MemoryPool {
      size: None,
      bytes: None,
      usage: None,
      maxmempool: None,
      mempoolminfee: None,
      minrelaytxfee: None
    }
  }

  pub fn set_size(&mut self, size: i64) {
    self.size = Some(size);
  }

  pub fn with_size(mut self, size: i64) -> MemoryPool {
    self.size = Some(size);
    self
  }

  pub fn size(&self) -> Option<&i64> {
    self.size.as_ref()
  }

  pub fn reset_size(&mut self) {
    self.size = None;
  }

  pub fn set_bytes(&mut self, bytes: i64) {
    self.bytes = Some(bytes);
  }

  pub fn with_bytes(mut self, bytes: i64) -> MemoryPool {
    self.bytes = Some(bytes);
    self
  }

  pub fn bytes(&self) -> Option<&i64> {
    self.bytes.as_ref()
  }

  pub fn reset_bytes(&mut self) {
    self.bytes = None;
  }

  pub fn set_usage(&mut self, usage: i64) {
    self.usage = Some(usage);
  }

  pub fn with_usage(mut self, usage: i64) -> MemoryPool {
    self.usage = Some(usage);
    self
  }

  pub fn usage(&self) -> Option<&i64> {
    self.usage.as_ref()
  }

  pub fn reset_usage(&mut self) {
    self.usage = None;
  }

  pub fn set_maxmempool(&mut self, maxmempool: i64) {
    self.maxmempool = Some(maxmempool);
  }

  pub fn with_maxmempool(mut self, maxmempool: i64) -> MemoryPool {
    self.maxmempool = Some(maxmempool);
    self
  }

  pub fn maxmempool(&self) -> Option<&i64> {
    self.maxmempool.as_ref()
  }

  pub fn reset_maxmempool(&mut self) {
    self.maxmempool = None;
  }

  pub fn set_mempoolminfee(&mut self, mempoolminfee: f32) {
    self.mempoolminfee = Some(mempoolminfee);
  }

  pub fn with_mempoolminfee(mut self, mempoolminfee: f32) -> MemoryPool {
    self.mempoolminfee = Some(mempoolminfee);
    self
  }

  pub fn mempoolminfee(&self) -> Option<&f32> {
    self.mempoolminfee.as_ref()
  }

  pub fn reset_mempoolminfee(&mut self) {
    self.mempoolminfee = None;
  }

  pub fn set_minrelaytxfee(&mut self, minrelaytxfee: f32) {
    self.minrelaytxfee = Some(minrelaytxfee);
  }

  pub fn with_minrelaytxfee(mut self, minrelaytxfee: f32) -> MemoryPool {
    self.minrelaytxfee = Some(minrelaytxfee);
    self
  }

  pub fn minrelaytxfee(&self) -> Option<&f32> {
    self.minrelaytxfee.as_ref()
  }

  pub fn reset_minrelaytxfee(&mut self) {
    self.minrelaytxfee = None;
  }

}



